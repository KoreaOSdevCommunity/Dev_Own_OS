2 | 레지스터들

우리가 사용하는 컴퓨터는 16비트, 32비트, 64비트가 있는데 이는 레지스터의 크기로 결정하는 것이다. 만일 레지스터의 크기가 32비트라면 현재 운영체제는 32비트 모드에서 작동하고 있는 것이다. 이번에는 
CPU가 연산을 할 때 사용하는 "레지스터"에 대해서 자세히 알아볼 것이다. 참고로 전에 강좌 세그멘테이션에서 말한것 처럼 16비트에서 세그멘테이션을 어떻게 실질적으로 사용하는지는 마지막에 설명을 해보겠다.

16비트를 기준으로 말했을 때 레지스터들은 AX, BX, CX, DX, AH, AL, BH, BL, CH, CL, DH, DL, SI , DI, ES, DS, CS, SS, FS, GS, BP, SP가 있다. 총 22개가 있다. 
X로 끝나는 레지스터들은 unsigned short, 2바이트이고 H와 L로 끝나는 레지스터들은 unsigned char, 1바이트 이다. SI와 DI, BP, SP도 모두 2바이트이고 나머지 S로 끝나는 것들은
이 중에서 H와 L로 끝나는 것들은 매우 특이한 레지스터들이다. H로 끝나는 레지스터 중 AH는 AX의 높은 부분\[0:8\]을 레지스터 형식으로 설명한 것이다
```
 |-------------------|-------------------|
 |             AX Register               |
 |-------------------|-------------------|
 |        AH         |        AL         |
 |-------------------|-------------------|
16                                      0
```
가령, AX가 0xFFAA라면 AL은 0xAA, AH는 0xFF가 되는 것이다. al, ah, bl, bh, cl, ch 등은 바이오스 인터럽트의 인자로도 사용이 된다.  
하지만 이것이 다가 아니다. 레지스터는 16비트 레지스터만 있는것이 아닌 32비트 레지스터, 64비트 레지스터까지 존재한다. 32비트 레지스터는 EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP가 있다.
각각의 레지스터들은 모두 4바이트로 unsigned int이다. 모두 E를 앞에 붙인것인데, 그 이유는 Extended(확장)의 약자로 앞에 E를 모두 붙인것이다. 그렇기 때문에 2바이트에서 레지스터의 크기가 
4바이트로 늘어났다. 여기에 왜 세그먼트 레지스터들을 모두 뺀 이유는, 16비트와 32비트, 64비트의 세그먼트 레지스터는 모두 같기 때문이다(세그멘테이션의 방법은 조금 달라지기는 하지만 이것은 나중에 
설명하겠다). 여기서 또 AX는 EAX의 낮은 부분\[0:16\]이 된다(EAX의 위에부분은 없다, 하지만 EAX레지스터를 0xFFFF0000으로 앤드 연산을 한 뒤에 오른쪽 시프트 레지스터로 16번 해주면 EAX레지스터의 
위의 부분을 얻을 수 있을 것이다).
```
 |-------------------|-------------------|
 |             EAX Register              |
 |-------------------|-------------------|
 |                   |        AX         |
 |-------------------|-------------------|
 32                  16                  0
```
64비트 레지스터도 AX레지스터에 R을 붙인것으로 RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP가 있다. 하지만 64비트는 매우 많은 것들이 추가되었다. 16비트와 32비트와는 다르게 64비트의 
레지스터에는 R8, R9, R10, R11, R12, R13, R14, R15라는 레지스터들이 있는데, 이 레지스터들은 딱히 큰 역할을 하지는 않고 연산을 하는 용도로 주로 사용이 된다.
RAX레지스터도 EAX와 같이 RAX의 아래 부분은 EAX이다. 참고로 64비트 레지스터들은 모두 64비트이다(unsigned long, 8바이트).
```
 |-------------------|-------------------|
 |             RAX Register              |
 |-------------------|-------------------|
 |                   |        EAX        |
 |-------------------|-------------------|
 64                  32                  0
```
여기서 설명을 하지 않은 부분이 있다. 바로 세그먼트와 세그멘테이션이 어떻게 실질적으로 작동하는지이다. 이것은 바로 세그먼트 레지스터에 해답이 있다. 데이터 세그먼트(DS)는 16비트에서 모든 데이터 어드레스에 사용되는 세그먼트이다. 예를 들어 보겠다. 만일 16비트 부트로더의 시작점을 0x00으로 설정하고 해당 코드에 변수를 만들었다 가정 한 뒤, 변수의 주소는 부트로더의 시작점을 기준으로 0x20이라고 하자.
이렇게 했을 때 부트로더는 0x7C00에 저장이 되면서 오류가 생길것이다. 왜냐하면 코드 안에서 변수의 주소는 0x20이지만 실제 변수가 있는 위치는 0x7C20이기 때문이다. 하지만 여기서 만일 데이터 세그먼트를 0x7C0으로 했을 때는 변수의 위치가 달라지게 된다. 16비트 세그멘테이션에 따라서 DS를 0x7C0으로 했을 때, 변수의 위치는 (0x7C0\*16)+0x20 = 0x7C20이 된다. 따라서 16비트에서 프로그래밍을 할 때에는 세그멘테이션과 세그먼트를 잊어버리지 않는것이 중요하다. 이 세그멘테이션은 스택의 범위를 정의하는데에도 매우 중요한데, 만일 SS가 0x100이고 BP가 0x200이라면, 스택의 시작점은 SS:BP, 0x100\*16+0x200 = 0x1200이 된다. 그리고 스택이 최대로 자랄 수 있는 주소는 SS:0x00, 0x100\*16 = 0x1000이 된다. 따라서 세그멘테이션은 스택의 범위를 정하는데에도 유용하게 사용한다.

