2 | 16비트 모드(리얼모드)와 부트로더
# 16비트 모드(리얼모드)와 부트로더
첫 튜토리얼 인가요? 제목을 보고 왔겠지만 16비트 모드라고 불리는 리얼모드 그리고 부트로더에 대해 이야기 해보겠습니다.
## 16비트(리얼)모드
16비트 모드 혹은 리얼모드라고 불리는 이 운영모드는 컴퓨터 전원을 키면 처음으로 로드되는 모드입니다.
이름 그대로 16비트 모드로 동작하며 8086 프로세서와 호환되는 모드입니다. 최대 1mb의 주소공간을 제공합니다. 
---
### 레지스터
운영모드에 상관없이 컴퓨터에는 많은 레지스터가 있으며 비슷한 용도에 따라서 분리되는데 가장 중요한 범용레지스터부터 세그먼트, 컨트롤 레지스터가 있습니다.
#### 범용 레지스터
|이름|용도|
|---|---|
|AX|산술연산을 수행할때 누산기로 사용|
|BX|데이터의 어드레스를 지정할 때 데이터 포인터로 활용|
|CX|루프 또는 문자열 카운터로 사용|
|DX|IO어드레스를 지정할때 사용|
|SI|문자열에 관련된 작업을 수행할때 원본 문자열의 인덱스로 활용|
|DI|문자열에 관련된 작업을 수행할때 목적지 문자열의 인덱스로 활용|
|SP|스택의 포인터로 활용|
|BP|스택의 데이터에 접근할때 데이터의 포인터로 사용|
|R8 ~ R15|x86-64프로세서에서 추가된 범용레지스타로, 다양한 용도로 사용가능|

보시다시피 범용레지스터는 상당히 많습니다.
그런데 이런 범용 레지스터는 모든 운영모드에 있습니다.
그럼 프로세서 내부에는 운영모드 별로 나뉘어 저장 되어 있을까요?
만약 그렇다면 프로세서에는 레지스터 수 * 운영모드 수만큼의 공간이 있어야합니다...
이는 생각만으로도 비효율적입니다. 실제로 프로세서에는 64비트 크기의 범용 레지스터가 있습니다. 리얼/보호모드에서는 이 크기에 일부만 사용하도록 하였습니다.
#### 세그먼트 레지스터
|이름|용도|
|---|---|
|CS|- 코드 영역을 가리키는 레지스터<br>- 데이터 이동 명령으로 값을 변경할수 없으며, 점프명령이나 인터럽트 관련 명령으로 변경 가능|
|DS|- 데이터 영역을 가리키는 레지스터|
|ES|- 데이터 이동명령으로 값을 변경할수 있음.|
||- DS는 데이터 영역에 접근할때 암시적으로 사용<br>- ES레지스터는 문자열과 관련된 작업을 처리할때 암시적으로 사용됨<br>- 데이터 영역에 접근하려면서 DS레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용|
|SS|- 스택영역을 가리키는 레지스터<br>- 데이터 이동 명령으로 값을 변경할수 있음.<br>- 스택관련 레지스터를 통해 스택에 접근할때 암시적으로 사용됨.|

세그먼트 레지스터는 범용레지스터 만큼이나 중요한 레지스터로서 코드나 데이터 영역을 구분할수 있는 중요한 레지스터입니다.
#### 컨트롤 레지스터
|이름|용도|
|---|---|
|CR0|- 운영모드를 제어하는 레지스터<br>- 리얼모드에서 보호모드로 전환하는 역할과 캐시, 페이징 기능 등을 활성화 시킴|
|CR1|- 프로세서에 의해 예약된 레지스터|
|CR2|- 페이지 폴트 발생시 페이지 폴트가 발생한 선형주소가 저장되는 레시스터<br>- 레이징 기법을 활성화한 후에는 페이지 폴트 발생시만 유효한 값을 가짐|
|CR3|- 페이지 디랙터리의 물리 주소와 페이지 캐시에 관련된 기능을 설정하는 레지스터|
|CR4|- 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터<br>- 페이지 크기 확장이나 메모리 영역확장 등의 기능을 활성화 시킴|
|CR8|- 태스크 우선순위 레지스터의 값을 제어하는 레지스터<br>- 프로세스 외부에서 발생하는 인터럽트를 걸러주는  필터의 역활<br>- IA-32e 모드에서만 접근가능|
---
### 부트로더 제작
만물에도 시작이 있다고 합니다. 이 내용은 OS도 마찬가지 입니다.
Windows도 Linux도 512바이트라는 작은 코드의 프로그램에서 시작됩니다.
이 프로그램의 이름은 바로 부트로더!
드디어 코딩입니다. 먼저 폴더 구성을 해봅시다.

<img src="https://raw.githubusercontent.com/Developer-CoderK/Dev_Own_OS/main/Step/Image/forder.png" alt="drawing" style="width:200px;"/>

이렇게 구성하였습니다.
그리고 16bit 폴더에 BootLoader에 BootLoader.asm파일을 추가해봅시다.

```
[ORG 0x00]  ; 프로그램의 시작을 0x00으로 정의
[BITS 16]   ; 이하의 코드는 16비트 코드로 설정

SECTION .text   ; text 세그먼트를 정의

mov ax, 0xB800  ; 연산을 위해 AX에 0xB800을 대입
mov ds,ax   ; ds에 ax를 대입해 세그먼트를 설정

mov byte [ 0x00 ], 'H'  ; 0xB800:0x00에 M을 넣는다.
mov byte [ 0x01 ], 0x4A ; 0xB800:0x01에 속성값 0x4a를 넣는다.

jmp $   ; 현재 위체에서 무한 루프 수행

times 510 - ( $ - $$ )   db 0x00 ; $ : 현재 어드레스 / $$ : 현재 세그먼트의 시작 어드레스 / time : 반복 수행

db 0x55 ; 1바이트를 0x55로 선언
db 0xAA ; 1바이트를 0xAA로 선언
```

이 코드는 정말 많은 것을 나타냅니다.
어셈블리를 모르는 분은 잘 이해가 되지않을겁니다.
한줄씩 볼까요?
`[ORG 0x00]` 이 코드는 프로그램의 시작주소를 나타내는 코드입니다. 해당 소스는 0x00에서 시작된다는 의미입니다.
`[BITS 16]` 이 코드는 코드가 16비트라는 의미입니다.
`SECTION .text` 은 영역을 지정하는 코드인데 .text로 되어있으니 소스라는 의미입니다.
`mov ax, 0xB800  mov ds,ax`는 중요한 코드입니다. 0xB800이라는 주소는 비디오 램의 주소입니다. 비디오 램이란 화면에 글을 출력하기 위한 주소입니다.
0xB800 부터 글씨, 속성값의 순서로 대입해주면 글씨가 출력됩니다.

```
mov byte [ 0x00 ], 'H'
mov byte [ 0x01 ], 0x4A
```

이 코드는 화면에 H를 출력하는 코드입니다.

```
times 510 - ( $ - $$ )   db 0x00 ; $ : 현재 어드레스 / $$ : 현재 세그먼트의 시작 어드레스 / time : 반복 수행

db 0x55 ; 1바이트를 0x55로 선언
db 0xAA ; 1바이트를 0xAA로 선언
```
이 코드는 부트로더의 형식을 맞게 하기 위한 코드입니다.
부트로더의 크기는 512이므로 510까지 00으로 채우는 코드입니다.
db 0x55 db 0xAA는 이 소스가 부트로더임을 알려주는 코드로 마지막에 55 AA를 넣어서 알려줍니다.
이제 Makefile을 만들어서 빌드 되도록 해봅시다.

```Makefile
# 최상위 디랙토리 MakeFile
all: BootLoader JotOS.img

BootLoader:
	@echo
	@echo ---------- 16비트 빌드 시작 ----------
	@echo
	
	make -C 16bit
	
	@echo
	@echo ---------- 16비트 빌드 성공 ----------
	
JotOS.img: 16bit/BootLoader/BootLoader.bin
	@echo
	@echo ---------- OS이미지 빌드 시작 ----------
	@echo
	
	cp 16bit/BootLoader/BootLoader.bin JotOS.img
	
	@echo
	@echo ---------- OS이미지 빌드 성공 ----------
	@echo
	
clean:
	make -C 16bit clean
	rm -f JotOS.img
```

```Makefile
# 16bit 디랙토리 Makefile
all: BuildBootLoader

BuildBootLoader:
	@echo
	@echo ---------- 부트로더 빌드 시작 ----------
	@echo
	
	make -C BootLoader
	
	@echo
	@echo ---------- 부트로더 빌드 성공 ----------
	@echo
	
clean:
	make -C BootLoader clean
```

```Makefile
# 16bit/BootLoader 디랙토리 Makefile
all: BootLoader.bin

BootLoader.bin: BootLoader.asm
	nasm -o BootLoader.bin BootLoader.asm
	
clean:
	rm -f BootLoader.bin
```
드디어 Make!~
오! 빌드가 잘되었습니다.
실행하기 전에 매일 입력할 qemu명령을 bat파일로 만들어 봅시다.

```
qemu-system-x86_64.exe -L "C:\Program Files\qemu" -m 64 -rtc base=localtime -fda ./JotOS.img -M pc
```
저는 이렇게 설정하였습니다.
그리고 실행하면....
![결과](https://raw.githubusercontent.com/Developer-CoderK/Dev_Own_OS/main/Step/Image/run1.png)
보이시나요? 위를 보면 빨간색바탕에 밝은 초록으로 H가 출력된걸 볼수있습니다!

---
다음 내용에서 부트로더를 완성시켜 보고 오늘은 이만 그만하도록 하겠습니다.

**참고**: JotOS라는 이름의 뜻은 Jot = 작은 이라는 뜻으로 작은 OS로 정했습니다.
